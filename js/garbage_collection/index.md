[<< 回到主页](http://suzy1993.github.io/misszy/)

## JavaScript 垃圾收集机制

### 1 垃圾收集机制
JavaScript具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。也就是说，所需内存的分配和无用内存的回收完全实现了自动管理。
垃圾回收机制的原理：垃圾收集器会按照固定的时间间隔或代码执行中预定的收集时间，周期性地执行以下操作——找出不再继续使用的变量，然后释放其占用的内存。

### 2 垃圾收集机制的两种方式
用于标识无用变量的方式有两种：标记清除法和引用计数法。
#### 2.1 标记清除法
javascript最常用的垃圾收集方式。当变量进入环境时，这个变量标记为“进入环境”；而当变量离开环境时，则将其标记为“离开环境”。可以使用一个“进入环境”的变量列表及一个“离开环境”的变量列表来跟踪变量的变化，也可以翻转某个特殊的位来记录一个变量何时进入环境及离开环境。

#### 2.2 引用计数法
不太常见的垃圾收集策略。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则该值的引用次数就是1；如果同一个值又被赋给另一个变量，则该值的引用次数加1；如果包含对该值引用的变量又取得了另外一个值，则该值的引用次数减1。当该值的引用次数变为0时，则可以回收其占用的内存空间。当垃圾回收器下一次运行时，就会释放那些引用次数为0的值所占用的内存。
问题：循环引用。
对象A包含一个指向对象B的指针，而对象B中也包含一个指向A的指针。
```
function obj() {
    var objA = new Object();
    var objB = new Object();
    objA.propertyA = objB;
    objB.propertyA = objA;
}
```
objA和objB的引用次数都是2，采用标记清除策略时，函数执行后，两个对象都离开了作用域，因此相互引用不是问题，但采用引用计数策略时，函数执行后，两个对象还将继续存在，因为它们的引用次数永远不会为0。
因此一般不推荐用引用计数法，推荐使用标记清除法。
然而，IE中有一部分对象并不是原生JavaScript对象，如BOM和DOM对象就是使用C++以COM（组件对象模型）对象的形式实现的，而COM对象的垃圾收集机制采用的就是引用计数策略，因此，即使IE的JavaScript引擎是使用标记清除策略实现的，但JavaScript访问的COM对象依然是基于引用计数策略的，也即是说，只要IE中涉及COM对象，就会存在循环引用的问题。
```
var element = document.getElementById("element");
var obj = new Object();
obj.property1 = element;
element.property2 = obj;
```
解决：手动断开两个对象之间的相互引用。
在使用完毕后，手动断开原生JavaScript对象与DOM元素之间的连接，消除循环引用。当垃圾回收器下一次运行时，就会会删除这些值并回收它们占用的内存。
```
obj.property1 = null;
element.property2 = null;
```
解除引用：
一旦数据不再有用，最好通过将其设置为null来释放其引用。
然而，解除一个值的引用不意味着自动回收该值所占用的内存，解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

[<< 回到主页](http://suzy1993.github.io/misszy/)
