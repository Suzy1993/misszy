[<< 回到主页](http://suzy1993.github.io/misszy/)

## ES6 let & const

### 1 ES6 let命令
ES6新增了let命令，用来声明变量，它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。
#### 1.1 for循环的计数器，就很合适使用let
```
var a = [];
for (var i = 0; i < 10; i++) {
    a[i] = function() {
        console.log(i);
    }
}
a[6](); // 10
```
变量i是var声明的，在全局范围内有效，所以每次循环新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。
```
var a = [];
for (let i = 0; i < 10; i++) {
    a[i] = function() {
        console.log(i);
    }
}
a[5](); // 5
```
使用let，声明的变量仅在块级作用域内有效，最后输出的是5。

#### 1.2 let不存在变量提升
let不像var那样会发生变量提升，所以，变量一定要在声明后使用，否则报错。
```
console.log(i); // 输出：undefined
console.log(j); // 报错
var i = 5;
let j = 10;
```

#### 1.3 暂时性死区
只要块级作用域存在let命令，它所声明的变量就绑定到这个区域，不再受外部的影响。
```
var i= 6;
if (i > 5) {
    i = 3; // 报错
    let i;
}
```
ES6明确规定，若块作用域中存在let和const命令，则它们声明的变量，从一开始就形成了封闭作用域，凡是在声明之前就使用这些变量，就会报错。
在代码块内，使用let命令声明变量之前，该变量都是不可用的（不可赋值，不可访问等），这称为“暂时性死区”。
暂时性死区使得typeof操作不一定安全，所以在let声明之前，使用typeof操作符会报错。而在let出现之前，typeof是百分之百安全的，永远不会被报错，即使变量没有被声明，typeof也会返回undefined。
```
if (true) {
    alert(typeof x); // 报错
    alert(typeof y); // undefined
    let x;
}
```
暂时性死区的本质：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止变量在声明前就使用该变量，从而导致意料之外的错误。这类错误在ES5中很常见。

#### 1.4 不允许重复声明
let不允许在相同作用域内，重复声明同一个变量。
```
function func() { // 报错
    var i= 1;
    let i = 1;
}
function func() { // 报错
    let i= 1;
    let i = 1;
}
```
不能在函数内部重新声明参数。
```
function func(arg) { // 报错
    let arg;
}
function func(arg) { // 不报错
    {
        let arg;
    }
}
```

### 2 ES6 const命令
const声明一个只读的常量，一旦声明，常量的值就不能改变，这意味着，const一旦声明常量，就必须立即初始化，不能等到之后再赋值。因此，改变常量和只声明不赋初始值都会报错。
const的作用域与let命令相同，只在声明所在的块级作用域内有效。
```
if (true) {
    const i = 5;
}
console.log(i); // 报错
```
const声明的常量也不提升，同时存在暂时性死区，只能在声明的位置后面使用。
```
if (true) {
    console.log(i); // 报错
    const i = 5;
}
```
const声明的常量，也和let一样不可重复声明。
```
var i = 5;
let j = 10;
const i =6; // 报错
const j = 11; // 报错
```
对于复合类型的常量，常量名不指向数据，而是指向数据所在的地址。const命令只是保证常量名指向的地址不变，并不保证该地址的数据不变，也就是说，将对象常量指向另一个地址会报错，但对象本身是可变的，可以为其添加，修改属性，因此将一个对象声明为常量必须十分小心。
```
const obj = {};
obj.name = “Alice”;
obj = {}; // 报错
```
将一个数组声明为常量，该数组本身是可写的，但是若将另一个数组赋值给该数组，会报错。
```
const arr = [];
arr.push(1);
arr = [1,2,3,4]; // 报错
```

### 3 let VS const
#### 3.1 let和const的相同点
①　只在声明所在的块级作用域内有效。
②　不提升，同时存在暂时性死区，只能在声明的位置后面使用。
③　不可重复声明。

#### 3.2 let和const的不同点
①　let声明的变量可以改变，值和类型都可以改变；const声明的常量不可以改变，这意味着，const一旦声明，就必须立即初始化，不能以后再赋值。
```
const i ; // 报错，一旦声明，就必须立即初始化
const j = 5;
j = 10; // 报错，常量不可以改变
```
②　数组和对象等复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const只保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个复合类型的变量声明为常量必须非常小心。
```
const arr = [];
// 报错，[1,2,3]与[]不是同一个地址
arr = [1,2,3];
const arr = [];
// 不报错，变量名arr指向的地址不变，只是数据改变
arr[0] = 1;
arr[1] = 2;
arr[2] = 3;
console.log(arr.length); // 输出：3
```
若想让定义的对象或数组的数据也不能改变，可以使用object.freeze(arr)进行冻结。冻结指的是不能向这个对象或数组添加新的属性，不能修改已有属性的值，不能删除已有属性。
```
const arr = [];
Object.freeze(arr);
// 不报错，但数据改变无效
arr[0] = 1;
arr[1] = 2;
arr[2] = 3;
console.log(arr.length); // 输出：0
```

[<< 回到主页](http://suzy1993.github.io/misszy/)
